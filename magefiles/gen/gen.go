package gen

import (
	"bytes"
	"encoding/xml"
	"errors"
	"fmt"
	"go/format"
	"io"
	"io/fs"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

func GenerateDir(path string) (err error) {
	return filepath.Walk(path, walk)
}

var lineRe = regexp.MustCompile(" line ([0-9]+):")

func walk(path string, info fs.FileInfo, walkErr error) (err error) {

	if walkErr != nil {
		return walkErr
	}
	if strings.HasSuffix(info.Name(), ".html") {
		err = Generate(path)
		if err != nil {
			subMatch := lineRe.FindAllStringSubmatch(err.Error(), 1)
			if len(subMatch) > 0 {
				path += ":" + subMatch[0][1]
			}
			err = fmt.Errorf("%s : %s", path, err)
		}
	}
	return err
}

func Generate(path string) (err error) {
	defer func() {
		r := recover()
		if r != nil {
			switch t := r.(type) {
			case error:
				err = t
			}
		}
	}()

	file := noError(os.Open(path))
	defer deferClose(file)

	pkg := filepath.Base(filepath.Dir(path))
	goFileName := strings.Replace(path, ".html", ".go", 1)

	goFile := noError(os.Create(goFileName))
	defer deferClose(goFile)

	var parents []*ParseData
	charBuffer := &charDataBuffer{}
	decoder := xml.NewDecoder(file)

	var token xml.Token
	for ; err == nil; token, err = decoder.Token() {
		switch t := token.(type) {
		case xml.StartElement:
			textData := charBuffer.pop()
			if len(textData) > 0 && len(parents) > 0 {
				parents[len(parents)-1].Text(textData)
			}
			ne := &ParseData{
				name:       t.Name.Local,
				attributes: AttrMap(t),
			}
			parents = append(parents, ne)
			if len(parents) > 1 {
				parent := parents[len(parents)-2]
				parent.children = append(parent.children, parents[len(parents)-1])
			}
		case xml.EndElement:
			textData := charBuffer.pop()
			if len(textData) > 0 && len(parents) > 0 {
				parents[len(parents)-1].Text(textData)
			}
			if len(parents) > 1 {
				parents = parents[:len(parents)-1]
			}
		case xml.CharData:
			charBuffer.Write(t)
		}
	}
	if len(parents) == 0 {
		err = errors.New("no parent elements")
	}
	if err != io.EOF && err != nil {
		return err
	}

	override := true
	overrideFile := filepath.Join(filepath.Dir(goFileName), "o"+filepath.Base(goFileName))
	if _, err = os.Stat(overrideFile); os.IsNotExist(err) {
		override = false
	}

	src := &bytes.Buffer{}
	err = parents[0].Write(override, pkg, src)
	if err != nil {
		return err
	}

	srcFmt := src.Bytes()
	if parents[0].DataNap("format") == "" {
		srcFmt, err = format.Source(srcFmt)
		if err != nil {
			panic(err)
		}
	}

	_, err = goFile.Write(srcFmt)
	if err != nil {
		panic(err)
	}

	return nil
}

// TODO: remove these two and panic at top of Run
func noError(in *os.File, err error) *os.File {
	if err != nil {
		panic(err)
	}
	return in
}

func deferClose(in *os.File) func() {
	return func() {
		err := in.Close()
		if err != nil {
			panic(err)
		}
	}
}

func Cap(in string) string {
	return strings.ToUpper(in[0:1]) + in[1:]
}

func AttrMap(x xml.StartElement) map[string]any {
	result := make(map[string]any)
	for _, attr := range x.Attr {
		result[attr.Name.Local] = attr.Value
	}
	return result
}

type ParseData struct {
	name       string
	attributes map[string]any
	children   []*ParseData
}

func (d *ParseData) Text(data string) {
	el := &ParseData{name: "#text", attributes: map[string]any{"data": data}}
	d.children = append(d.children, el)
}

func (d *ParseData) DataNap(suffixes ...string) string {
	key := "data-nap"
	if len(suffixes) > 0 {
		key += "-" + strings.Join(suffixes, "-")
	}
	if dm, ok := d.attributes[key].(string); ok {
		return dm
	}
	return ""
}

func (d *ParseData) Write(override bool, pkg string, buffer *bytes.Buffer) error {
	prefix := d.DataNap("prefix")
	if prefix == "" {
		return fmt.Errorf("element %q requires data-nap-prefix around line 2: ", d.name)
	}

	header := `
// Package %s is autogenerated, do not edit
package %s
import (
  "github.com/mlctrez/go-nap/nap"
)
`
	buffer.WriteString(fmt.Sprintf(header, pkg, pkg))

	wl := func(f string, args ...any) {
		buffer.WriteString(fmt.Sprintf(f+"\n", args...))
	}

	wl("func %s(r nap.Router) {", Cap(prefix))
	for _, dn := range d.allDataNap() {
		if dn.DataNap("page") != "" {
			wl("r.ElmFunc(%q, %s)", "page-"+dn.DataNap("page"), Cap(dn.DataNap()))
		}
		if dn.DataNap("body") != "" {
			wl("r.ElmFunc(%q, %s)", "body-"+dn.DataNap("body"), Cap(dn.DataNap()))
		}
		if dn.DataNap("key") != "" {
			wl("r.ElmFunc(%q, %s)", dn.DataNap("key"), Cap(dn.DataNap()))
		} else {
			wl("r.ElmFunc(%q, %s)", prefix+"/"+dn.DataNap(), Cap(dn.DataNap()))
		}
	}
	wl("}")

	for _, child := range d.allDataNap() {
		wl("")
		wl("func %s(r nap.Router) nap.Elm{", Cap(child.DataNap()))
		wl(" el := %s", child.declaration(prefix))
		if override {
			wl("return Override(r, %q,el)", prefix+"/"+child.DataNap())
		} else {
			wl("return el")
		}
		wl("}")
	}
	return nil
}

func (d *ParseData) declaration(prefix string) (decl string) {
	var attrMap []string
	for k, v := range d.attributes {
		if !strings.HasPrefix(k, "data-nap") {
			attrMap = append(attrMap, fmt.Sprintf("%q:%q", k, v))
		}
	}

	if len(attrMap) == 0 {
		decl = fmt.Sprintf("r.E(%q)", d.name)
	} else {
		var attrDef string
		switch len(attrMap) {
		case 1, 2, 3:
			attrDef = fmt.Sprintf("nap.M{%s}", strings.Join(attrMap, ","))
		default:
			attrDef = fmt.Sprintf("nap.M{\n%s,\n}", strings.Join(attrMap, ",\n"))
		}

		decl = fmt.Sprintf("r.E(%q,%s)", d.name, attrDef)
	}
	var childDecl []string
	for _, child := range d.children {
		if child.DataNap("omit") == "true" {
			continue
		}
		switch child.name {
		case "#text":
			de := fmt.Sprintf("nap.Text(%q)", child.attributes["data"])
			childDecl = append(childDecl, de)
		default:
			if child.DataNap() != "" {
				childDecl = append(childDecl, fmt.Sprintf("r.Elm(%q)", prefix+"/"+child.DataNap()))
				continue
			}
			childDecl = append(childDecl, child.declaration(prefix))
		}
	}
	if len(childDecl) > 0 {
		if len(childDecl) > 2 {
			decl += fmt.Sprintf(".\nAppend(\n%s,\n)", strings.Join(childDecl, ",\n"))
		} else {
			decl += fmt.Sprintf(".\nAppend(%s)", strings.Join(childDecl, ","))
		}
	}

	return decl
}

func (d *ParseData) allDataNap() (result []*ParseData) {
	if d.DataNap() != "" {
		result = append(result, d)
	}
	for _, child := range d.children {
		result = append(result, child.allDataNap()...)
	}
	return result
}

type charDataBuffer struct {
	bytes.Buffer
}

func (cd *charDataBuffer) pop() string {
	charData := cd.String()
	cd.Reset()
	// TODO: revisit
	return strings.TrimSpace(charData)
}
